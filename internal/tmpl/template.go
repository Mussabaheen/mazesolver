package tmpl

import (
	"bytes"
	"encoding/json"
	"html/template"
	"math/rand"
	"time"
)

func makeKey() string {
	rand.Seed(time.Now().UnixNano())
	var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
	alphabets := make([]rune, 7)
	for i := range alphabets {
		alphabets[i] = letters[rand.Intn(len(letters))]
	}
	return string(alphabets)
}

func makeRange(max int) []int {
	arr := make([]int, max)
	for i := range arr {
		arr[i] = +i
	}
	return arr
}

func makeMonstorOrExit() string {
	outcomes := []string{"tiger", "voldemort", "pennywiseClown", "DarthVader", "exit"}
	rand.Seed(time.Now().UnixNano())
	min := 0
	max := len(outcomes) - 1
	return outcomes[rand.Intn(max-min+1)+min]
}

func GenerateMaze(maxChild int) (map[string]interface{}, error) {
	template, err := template.New("json.tmpl").Funcs(template.FuncMap{
		"makeKey":           makeKey,
		"makeMonstorOrExit": makeMonstorOrExit,
	}).ParseFiles("internal/tmpl/json.tmpl")

	if err != nil {
		return map[string]interface{}{}, err
	}

	var mazeGenerated bytes.Buffer

	depthMaze := makeRange(maxChild)

	err = template.ExecuteTemplate(&mazeGenerated, "json.tmpl", map[string]interface{}{
		"Children": depthMaze,
		"Height":   depthMaze,
		"Length":   maxChild - 1,
	})
	if err != nil {
		return map[string]interface{}{}, err
	}

	var mazeJSON map[string]interface{}

	err = json.Unmarshal(mazeGenerated.Bytes(), &mazeJSON)
	if err != nil {
		return map[string]interface{}{}, err
	}
	return mazeJSON, nil
}
